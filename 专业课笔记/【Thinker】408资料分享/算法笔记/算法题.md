# [算法题]()

## 注意事项

答题时注意以下细节：

1. 功能是否全部实现，临界情况是否考虑
2. 关键字拼写是否正确，如return while
3. 函数类型需要返回值的，是否最后return返回
4. 必要的变量声明是否需要赋初值

## 必会算法

### 快排

#### 快排代码

```c
int huafen(int A[],int low,int high){
    int mid=A[low];
    while(low<high){
        while(low<high && A[high]>=mid)
            high--;
        A[low]=A[high];
        while(low<high && A[low]<=mid)
            low++;
        A[high]=A[low];
    }
    A[low]=mid;
    return low;
}

void QuickSort(int A[],int low,int high){
    if(low>=high)
        return ;
    int mid=huafen(A,low,high);
    QuickSort(A,low,mid-1);
    QuickSort(A,mid+1,high);
}
```

#### 快排思想之划分

使用“划分”寻找第k小的元素

```c
int huafen(int A[],int low,int high){
    int mid=A[low];
    while(low<high){
        while(low<high && A[high]>=mid)
            high--;
        A[low]=A[high];
        while(low<high && A[low]<=mid)
            low++;
        A[high]=A[low];
    }
    A[low]=mid;
    return low;
}

int find(int A[],int n,int k){
    int low=0,high=n-1;mid=0;
    while(1){
        mid=huafen(A,low,high);
        if(mid==k-1)
            break;
        else if(mid>k-1)
            high=mid-1;
        else low=mid+1;
    }
    return A[k-1];
}
```

### 归并

```c
void Merge(int A[],int N,int B[],int M,int C[]){
    int i=0,j=0,k=0;
    while(i<N&&j<M)
    {
        if(A[i]<=B[j])
            C[k++]=A[i++];
        else
            C[k++]=B[j++];
    }
    while(i<N)
        C[k++]=A[i++];
    while(j<M)
        C[k++]=B[j++];
}
```

### 链表

定义

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;
```

求链表长度

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

int listLen(LinkList L){
    int length=0;
    LNode *p=L->next;
    while(p!=NULL){
        length++;
        p=p->next;
    }
    return length;
}
```

返回单链表的中间节点

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

LNode *FindMidNode(LinkList L){
    int length=0;
    LNode *p=L->next;
    while(p!=NULL){
        length++;
        p=p->next;
    }
    int count=0;
    p=L->next;
    while(p!=NULL){
        count++;
        if(count==length/2)
            break;
        p=p->next;
    }
    return p;
}
```

删除值为x的节点

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

void DeleteX(LinkList L,int x){
    LNode *pre=L;
    LNode *p=L->next;
    while(p!=NULL){
        if(p->data==x){
            LNode *q=p;
            p=p->next;
            pre->next=p;
            free(q);
        }else{
            pre=p;
            p=p->next;
        }
    }
}
```

在递增有序链表中插入值为x的节点，仍保持有序

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

void InsertX(LinkList L,int x){
    LNode *pre=L;
    Lnode *p=L->next;
    while(p!=NULL){
        if(p->data>=x)
            break;
        else
        {
            pre=p;
            p=p->next;
        }
    }
    LNode *q=(LNode *)malloc(sizeof(LNode));
    q->data=x;
    q->next=p;
    pre->next=q;
}
```

头插法实现链表原地逆置

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

void ListReserve(LinkList L){
    LNode *head=(LNode *)malloc(sizeof(LNode));
    head->next=NULL;
    while(L->next!=NULL){
        LNode *p=L->next;
        L-next=L->next->next;
        p->next=head->next;
        head->next=p;
    }
    L->next=head->next;
    free(head);
}
```

尾插法：保持原序合并或拆分链表

例：设C={a1,b1,a2,b2,...,an,bn}为线性表，采用带头结点的单链表存储，设计一个就地算法，将其拆分为两个线性表A={a1,a2,...,an}，B={bn,bn-1,...,b1}

```c
typedef struct LNode{
    int data;
    struct LNode *next;
}LNode,*LinkList;

LinkList A=NULL;
LinkList B=NULL;
void func(LinkList C){
    A=(LNode *)malloc(sizeof(LNode));
    A->next=NULL;
    B=(LNode *)malloc(sizeof(LNode));
    B->next=NULL;
    LNode *tailA=A;
    int count=1;
    while(C->next!=NULL){
        LNode *p=C->next;
        C->next=C->next->next;
        if(count%2==0){
            p->next=B->next;
            B->next=p;
        }else{
            p->next=NULL;
            tailA->next=p;
            tailA=p;
        }
        count++;
    }
}
```

### 二叉树

节点定义，先中后序遍历

```c
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

//先序遍历
void PreOrder(BiTree root,int height){	//使用参数传递树高height，可用于计算WPL等，不使用可去除
    if(root==NULL)
        return ;
    visit(root);
    PreOrder(root->lchild,height+1);
    PreOrder(root->rchild,height+1);
}

//中序遍历
void InOrder(BiTree root){
    if(root==NULL)
        return ;
    InOrder(root->lchild);
    visit(root);
    InOrder(root->rchild);
}

//后序遍历
int PostOrder(BiTree root){	//使用返回值返回各子树长度，可用于判断是否平衡: |l-r|≤1，不使用可改为void
    if(root==NULL)
        return ;
    int l=PostOrder(root->lchild);
    int r=PostOrder(root->rchild);
    visit(root);
    if(l>r)
        return l+1;
    else
        return r+1;
}
```

层序遍历

```c
// 二叉树的定义
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 队列的定义
#define MaxSize 500
typedef struct {
    BiTNode *data[MaxSize];
    int head, rear;
} Queue;

// 初始化队列
bool InitQueue(Queue *Q) {
    Q->head = Q->rear = 0;
    return true;
}

// 队列判空
bool QueueEmpty(Queue Q) {
    return Q.head == Q.rear;
}

// 判满
bool QueueFull(Queue Q) {
    return Q.head == (Q.rear + 1) % MaxSize;
}

// 入队
bool EnQueue(Queue *Q, BiTNode *x) {
    if (QueueFull(Q))
        return false;
    Q->data[Q->rear] = x;
    Q->rear = (Q->rear + 1) % MaxSize;
    return true;
}

// 出队
bool DeQueue(Queue *Q, BiTNode *x) {
    if (QueueEmpty(*Q))
        return false;
    x = Q->data[Q->head];
    Q->head = (Q->head + 1) % MaxSize;
    return true;
}

// 层序遍历
void LevelOrder(BiTree T) {
    Queue Q;
    InitQueue(&Q);
    BiTNode *p;
    if (T != NULL) EnQueue(&Q, T);

    while (!QueueEmpty(Q)) {
        DeQueue(&Q, &p);
        visit(p);
        if (p->lchild != NULL)
            EnQueue(&Q, p->lchild);
        if (p->rchild != NULL)
            EnQueue(&Q, p->rchild);
    }
}
```

求树高

```c
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

//①先序+全局变量+参数传递
int height=0;
void PreOrder(BiTree T,int n){	//调用方式：PreOrder(root,1);
    if(T==NULL) return ;
    if(n>height) height=n;
    PreOrder(T->lchild,n+1);
    PreOrder(T->rchild,n+1);
}
//②后序+返回值
int PostOrder(BiTree T){	//调用方式：int height=PostOrder(root);
    if(T==NULL) return 0;
    int left=PostOrder(T->lchild);
    int right=PostOrder(T->rchild);
    if(left>right)
        return left+1;
    else
        return right+1;
}

```

求树宽

```c
typedef struct BiTNode{
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

int width[MAX];		//统计各层节点总数
int maxWidth;		//记录最大宽度
void PreOrder(BiTree T,int level){
    if(T==NULL)	return ;
    width[level]++;
    if(width[level]>maxWidth)
        maxWidth=width[level];
    PreOrder(T->lchild,level+1);
    PreOrder(T->rchild,level+1);
}
int TreeWidth(BiTree T){
    for(int i=0;i<MAX;i++)
        width[i]=0;
    maxWidth=0;
    PreOrder(T,0);
    return maxWidth;
}
```

求WPL

```c
//节点中添加权值weight
typedef struct BiTNode{
    int weight;
    int data;
    struct BiTNode *lchild,*rchild;
}BiTNode,*BiTree;

int WPL=0;
void PreOrder(BiTree T,int level){		//调用PreOrder(root,0)即可求出树高
    if(T==NULL)
        return ;
    if(T->lchild==NULL && T->rchild==NULL)
        WPL+=level*T->weight;
    PreOrder(T->lchild,level+1);
    PreOrder(T->rchild,level+1);
}
```

树形判定：二叉排序树

```c
//错误做法：遍历每个节点，判断是否：左<中<右
//正确做法：中序遍历，看遍历节点是否是升序序列

int temp=MIN_INT;		//记录当前遍历的最小值
bool IsBST=true;		//是否为二叉排序树？
void InOrder(BiTree T){
    if(T==NULL)
        return ;
    InOrder(T->lchild);
    if(T->data>temp)
        temp=T->data;
    else
        IsBST=false;
    InOrder(T->rchild);
}//调用InOrder(root)，执行结束后若IsBST=ture，则为二叉排序树，否则不是
```

树形判定：平衡二叉树

```c
bool IsBalance=true;
int PostOrder(BiTree T){
    if(T==NULL)
        return 0;
    int left=PostOrder(T->lchild);
    int right=PostOrder(T->rchild);
    if(left-right>1 ||left-right<-1)
        IsBalance=false;
    if(left>right)
        return left+1;
    else
        return right+1;
}//调用PostOrder(root),执行结束后若IsBalance=true，则为二叉平衡树，否则不是
```

树形判定：完全二叉树(了解，要用队列，太多了，也就出应用题)

```c
// 二叉树的定义
typedef struct BiTNode {
    int data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 队列的定义
#define MaxSize 500
typedef struct {
    BiTNode *data[MaxSize];
    int head, rear;
} Queue;

// 初始化队列
bool InitQueue(Queue *Q) {
    Q->head = Q->rear = 0;
    return true;
}

// 队列判空
bool QueueEmpty(Queue Q) {
    return Q.head == Q.rear;
}

// 判满
bool QueueFull(Queue Q) {
    return Q.rear == (Q.head + 1) % MaxSize;
}

// 入队
bool EnQueue(Queue *Q, BiTNode *x) {
    if (QueueFull(Q))
        return false;
    Q->data[Q->rear] = x;
    Q->rear = (Q->rear + 1) % MaxSize;
    return true;
}

// 出队
bool DeQueue(Queue *Q, BiTNode *x) {
    if (QueueEmpty(*Q))
        return false;
    x = Q->data[Q->head];
    Q->head = (Q->head + 1) % MaxSize;
    return true;
}

bool IsComplete=true;	//是否为完全二叉树？
bool flag=false;		//flag=true，表示层序遍历中出现过叶节点或者只有左孩子的分支节点
void visit(BiTNode *p){
    if(p->lchild==NULL && p->rchild==NULL)	flag=true;	//叶节点
    if(p->lchild==NULL && p->rchild!=NULL)	//无左有右，非完全
        IsComplete=false;
    if(p->lchild!=NULL && p->rchild==NULL)	//有左无右
    {
        if(flag)	//之前已经出现过，则非完全
            IsComplete=false;
        flag=true;	//记：已出现
    }
    if(p->lchild!=NULL && p->rchild!=NULL)	//有左有右
        if(flag)	//之前已经出现过，则非完全
            IsComplete=false;
}
    
// 层序遍历
void LevelOrder(BiTree T) {
    Queue Q;
    InitQueue(&Q);
    BiTNode *p;
    if (T != NULL) EnQueue(&Q, T);

    while (!QueueEmpty(Q)) {
        DeQueue(&Q, &p);
        visit(p);
        if (p->lchild != NULL)
            EnQueue(&Q, p->lchild);
        if (p->rchild != NULL)
            EnQueue(&Q, p->rchild);
    }
}
```

### 图

邻接矩阵定义

```c
#define MAXV 100
typedef struct{
    int numV,numE;
    char VList[MAXV];
    int Edge[MAXV][MAXV];
}MGrpah;

int main(){
    MGraph *G=(MGraph *)malloc(sizeof(MGraph));
    for(int i=0;i<MAXV;i++)
        for(int j=0;j<MAXV;j++)
            G->Edge[i][j]=0;
    G->numV=4;
    G->numE=5;
    G->VList[0]='a';
    ...
    G->Edge[0][1]=1;
   
}
```

邻接表定义

```c
#define MAXV 100
typedef struct EdgeNode{	//边表节点
    int index;
    struct EdgeNode *next;
    int weight;				//权值，无权图可删
}EdgeNode;

typedef struct VertexNode{
    char data;
    EdgeNode *first;
}VertexNode, VertexList[MAXV];

typedef struct{
   	VertexList list;
    int numVertex,numEdge;
}ALGraph;

void AddEdge(ALGraph *G,int i,int j,int weight){
    EdgeNode *p=(EdgeNode *)malloc(sizeof(EdgeNode));
    p->weight=weight;
    p->index=j;
    p->next=G->list[i].first;	//单链表头插法
    G->list[i].first=p;
}
int main(){
    ALGraph *G=(ALGraph *)malloc(sizeof(ALGraph));
    for(int i=0;i<MAXV;i++)
        G->list[i].first=NULL;
    G->numVertex=4;
    G->numEdge=5;
    G->list[0].data='a';
    ...
    G->list[3].data='d';
    AddEdge[G,0,1,1];
}
```

BFS

```c
//邻接矩阵
bool visited[MAX];
void BFSTraverse(Graph G){
    for(int i=0;i<G.vexnum;i++)
        visited[i]=false;
    Queue Q;
    InitQueue(Q);
    for(int i=0;i<G.vexnum;i++)
        if(!visited[i])
            BFS(G,i);
}
void BFS(MGraph G,int i){
    visit[i];
}
```



## 王道习题

### 线性表

#### 2.2 线性表的顺序表示

1. 从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。

   ```c
   bool Delete_min(SqList &L,ElemType e){
       if(L.length==0)
           return false;
       e=L.data[0];	//记第一个元素为最小值
       int i,pos=0;
       for(i=1;i<L.length;i++)		//从第二个元素开始便利寻找最小值并记录对应的下标
           if(L.data[i]<e)
           {
               e=L.data[i];
               pos=i;
           }
       L.data[pos]=L.data[L.length-1];
       L.length--;
       return true;
   }
   ```

2. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为 0(1)。

   ```c
   void Reverse(SqList &L){
       ElemType t;
       int i=0;
       for(;i<L.length/2;i++)
       {
           t=L.data[length-1-i];
           L.data[length-1-i]=L.data[i];
           L.data[i]=t;
       }
   }
   ```

3. ##### ✨对长度为 n的顺序表L，编写一个时间复杂度为 0(n)、空间复杂度为 0(1)的算法，该算法删除顺序表中所有值为x的数据元素。

   ```c
   //用k记录顺序表L中不等于x的元素个数，扫描时将不等于x的元素移动到下标k的位置，并更新k值。扫描结束后修改L的长度
   void del_x_1(SqList &L,ElemType x){
       int k=0,i;
       for(i=0;i<L.length;i++)
           if(L.data[i]!=x)
               L.data[k++]=L.data[i];
       L.length=k;
   }
   
   //用k记录顺序表中等于x的元素个数，一边扫描L，一边统计k，并将不等于x的元素前移k个位置，扫描结束后修改L的长度
   void del_x_2(SqList &L,ElemType x){
       int k=0,i;
       for(i=0;i<L.length;i++){
           if(L.data[i]!=x)
               L.data[i-k]=L.data[i];
           else
               k++;
       }
       L.length=L.length-k;
   }
   ```

4. ##### ✨从顺序表中删除其值在给定值s和t之间(包含s和t，要求s<t)的所有元素，若s或t不合理或顺序表为空，则显示出错信息并退出运行。

   ```c
   bool Delete_among_s_t(SqList &L,ElemType s,ElemType t){
       if(s>=t || L.length==0)
           return false;
       for(int i=0;i<L.length;i++)
           if(L.data[i]>=s &&L.data[i]<=t){
               for(int j=i;j<L.length-1;j++)
                   L.data[j]=L.data[j+1];
               L.length--;
               i--;	//注意：如果i不回退一步，则会跳过原来被删除元素的下一个元素。eg：a[0]被删除，a[1]移到了a[0]，如果i不回退，就会跳过对原来a[1]的检查
           }
       return true;
   }
   
   //王道答案：遍历L，用k记录符合删除条件的元素个数，遇到符合的元素k++，遇到不符合的元素向前移动k位覆盖待删除元素
   bool Del_s_t(SqList &L,ElemType s,ElemType t){
       int i,k=0;
       if(s>=t || L.length==0)
           return false;
       for(i=0;i<L.length;i++){
           if(L.data[i]>=s && L.data[i]<=t)
               k++;
           else
               L.data[i-k]=L.data[i];		//不符合删除条件的元素就前移k位来覆盖需要删除的元素
       }
       L.length-=k;
       return true;
   }
   ```

5. ##### ✨从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

   ```c
   void Delete(SqList &L){
       if(L.length <= 1)
           return;
       
       int k = 0;  // k 记录新数组的有效长度
       for(int i = 1; i < L.length; i++){
           if(L.data[k] != L.data[i]){  // 找到与前一个元素不相等的元素
               L.data[++k] = L.data[i];  // 将它移到前一个元素的后面
           }
       }
       
       L.length = k + 1;  // 更新顺序表的有效长度
   }
   
   ```

6. ##### ✨将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。

   ```c
   bool Union(SqList a,SqList b,Sqlist &c){	//假定a和b均为升序有序表 
       if(a.length+b.length>c.maxSize) 	//若a和b的总长大于c的最大容量，无法合并
           return false
       int i=0,j=0,k=0;
       while(i<a.length&&j<b.length){
           if(a.data[i]<=b.data[j])
               c.data[k++]=a.data[i++];
           else
               c.data[k++]=b.data[j++];
       }
       while(i<a.length)
           c.data[k++]=a.data[i++];
       while(j<b.length)
           c.data[k++]=b.data[k++];
       c.length=k;
       return true;
   }
   ```

7. ##### ✨已知在一维数组 A[m+n]中依次存放两个线性表(a1,a2, a3,…,am)和(b1,b2,b3,…,bn)。编写一个函数,将数组中两个顺序表的位置互换,即将(b1,b2,b3,…,bn)放在(a1,a2,a3,…,am)的前面。

   ```c
   //暴力：声明一个数组B[m+n]，遍历A填充B，最后复制B到A
       
   //王道优解：先全部逆置数组A，然后对前n个元素和后m个元素分别逆置
   typedef int DataType;
   void reserve(DataType A[],int left,int right,int arraySize){
       if(left>=right || right>=arraySize)
           return ;
       int mid=(left+right)/2;
       for(int i=0;i<=mid-left;i++){	//***
           DataType temp=A[left+i];
           A[left+i]=A[right-i];
           A[right-i]=temp;
       }
   }
   void change(DataType A[],int m,int n,int arraySize){
       reverse(A,0,m+n-1,arraySize);
       reverse(A,0,n-1,arraySize);
       reverse(A,n,m+n-1,arraySize);
   }
   ```

   

8. ##### ✨线性表(a1,a2,a3,…,an)中的元素递增有序且按顺序存储于计算机内。要求设计一个算法完成用最少时间在表中查找数值为x的元素，若找到，则将其与后继元素位置相交换若找不到，则将其插入表中并使表中元素仍递增有序。

   ```c
   //查找线性表可以使用顺序查找和折半查找，题中要求最少时间，则用折半查找
   bool Find_x_zheban(Sqlist &L,ElemType x){
       int left=0,right=L.length-1,mid=0;
       while(left<=right){		//折半查找
           mid=(left+right)/2;
           if(L.data[mid]==x)
               break;
           else
               if(L.data[mid]<x)
                   left=mid+1;		//此处决定了x不存在时，left指向的是比x大的第一个值，因此下面的插入x是插入到left位置
           else
               right=mid-1;
       }
       if(L.data[mid]==x){
           if(mid==L.length-1)	//无后继元素
               return false;
           ElemType temp;
           temp=L.data[mid];
           L.data[mid]=L.data[mid+1];
           L.data[mid+1]=temp;
           return true;
       }
       if(left>right){
           if(L.length+1>L.maxSize)
               return false;	//若新加入x后会超过最大容量，则返回错误
           L.length++;
           for(int j=L.length-1;j>left;j--)
           	L.data[j]=L.data[j-1];
           L.data[left]=x;
           return true;
       }
   }
   ```

9. 给定三个序列 A、B、C，长度均为n，且均为无重复元素的递增序列，请设计一个时间上尽可能高效的算法，逐行输出同时存在于这三个序列中的所有元素。例如，数组A为{1,2,3}，数组 B为{2,3,4}，数组C为{-1,0,2}，则输出 2。要求:

   1)给出算法的基本设计思想。

   2)根据设计思想，采用C或 C++语言描述算法，关键之处给出注释。

   3)说明你的算法的时间复杂度和空间复杂度。

   ```c
   //1)同时遍历三个数组，输出相同元素
    
   void Find_same(int a[],int b[],int c[],int n)
   {
       int i=0,j=0,k=0;
       while(i<n&&j<n&&k<n){
           if(a[i]==b[j]&&b[j]==c[k]){		//相同则输出
               printf("%d\n",a[i]);
               i++;j++;k++;
           }
           else//不同则使最小的元素的位置向前移动一位。c语言中没有max函数，否则可比较出最大的元素，并使其他元素位置++
               if(a[i]<b[j]&&a[i]<c[k])	
                   i++;
           else
               if(b[j]<a[i]&&b[j]<c[k])
                   j++;
           else
               if(c[k]<a[i]&&c[k]<b[j])
                   k++;
       }
   }
   
   //3)时间复杂度O(n),空间复杂度O(1)
   ```

   

10. 【2010 统考真题】设将n(n>1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(X0,X1,…,Xn-1)变换为(Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1)。要求:

   1)给出算法的基本设计思想。

   2)根据设计思想，采用C或 C++或 Java 语言描述算法，关键之处给出注释

   3)说明你所设计算法的时间复杂度和空间复杂度。

   ```c
   //1)
   
   void LeftMove(int R[],int n,int p){
       if(p<=0||p>n ||n<=1)
           return ;
       int i=0;
       for(;i<n;i++)
           R[i]=
   }
   ```

   

11. 

12. 

13. 【2011 统考真题】一个长度为 L(L≥1)的升序序列 S，处在第[L/2]个位置的数称为 S的中位数。例如，若序列S1=(11,13,15,17,19 )，则S的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是 11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求:
    1)给出算法的基本设计思想。

    2)根据设计思想，采用C或 C++或 Java 语言描述算法，关键之处给出注释

    3)说明你所设计算法的时间复杂度和空间复杂度。

14. 





#### 2.3 线性表的链式表示

1. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。

   ```c
   void Delete(Linklist &L,ElemType x){
       LinkNode *pre=L,*p=L->next,*q;	//q指向被删除节点
       while(p){
           if(p->data==x)
           {
               q=p;
               p=p->next;
               pre->next=p;
               free(q);
           }else{
               pre=p;
               p=p->next;
           }
       }
   }
   
   //法二：在L头节点处尾插法重新建立单链表，保留值不为x的节点，释放值为x的节点
   void Delete_2(Linklist &L,ElemType x){
       LNode *p=L->next,*r=L,*q;	//r指向新单链表的尾节点，初值为原单链表头节点
       while(p!=NULL){
           if(p->data!=x){
               r->next=p;	//将p插入新单链表中
               r=p;		//更新尾节点
               p=p->next		//继续遍历原单链表
           }else
           {
               q=p;
               p=p->next;
               free(q);	//释放q节点
           }
       }
       r->next=NULL;		//插入结束后置尾节点指针为NULL
   }
   ```

2. 试编写在带头结点的单链表L中删除一个最小值结点的高效算法(假设该结点唯一)。

   ```c
   void Delete_min(Linklist &L){
       if(!L->next)
           return;//若是空链表，结束
       LNode *p=L->next,*pre=L,*premin=L;
       ElemType min=p->data;
       while(p!=NULL){
           if(p->data<min){
               min=p->data;//更新最小值
               premin=pre;	//更新最小值节点的前节点
           }
           pre=p;
           p=p->next;
       }
       p=premin->next;
       premin->next=p->next;
       free(p);
   }
   ```

3. 试编写算法将带头结点的单链表就地逆置，所谓“就地”是指辅助空间复杂度为 O(1)。

   ```c
   void reserve(Linklist &L){//头插法重新建立单链表
       LNode *p=L->next,*q;
       L->next=NULL;	//将头节点的next置空，否则q->next=L->next;会形成环
       while(p!=NULL){
           q=p;
           p=p->next;	//先向后移动p，再插入节点
           q->next=L->next;
           L->next=q;
       }
   }
   
   //法二：更改每个节点的next指向，该为指向其pre节点，最后将L指向尾节点
   void reserve_2(Linklist &L){
       LNode *pre,*p=L->next,*r=p->next;
       p->next=NULL;	//原链表中的头节点后面的节点转置后是新链表最后一个节点，因此next为NULL
       while(r!=NULL){
           pre=p;	//遍历原链表
           p=r;
           r=r->next;	
           p->next=pre;	//next反转
       }
       L->next=p;	//L指向新链表的尾节点，完成转置
   }
   ```

4. 设在一个带表头结点的单链表中，所有结点的元素值无序，试编写一个函数，删除表中所有介于给定的两个值(作为函数参数给出)之间的元素(若存在)。

   ```c
   void delete(LinkList &L,ElemType a,ElemType b){	//假定a<b
       if(a>=b)
           return ;
       LNode *p=L->next,*pre=L,*q;
       while(p!=NULL){
           if(p->data>a && p->data<b){
               q=p;
               p=p->next;
               pre->next=p;
               free(q);
           }
           else{
               pre=p;
               p=p->next;
           }
       }
   }
   ```

   

5. 给定两个单链表，试分析找出两个链表的公共结点的思想(不用写代码)。

   ​	两个单链表有公共结点，即两个链表从某一结点开始，它们的 next 都指向同一结点。由于每个单链表结点只有一个 next 域，因此从第一个公共结点开始，之后的所有结点都是重合的，不可能再出现分叉。所以两个有公共结点而部分重合的单链表，拓扑形状看起来像Y，而不可能像 X。本题极容易联想到“蛮”方法:在第一个链表上顺序遍历每个结点，每遍历一个结点，在第二个链表上顺序遍历所有结点，若找到两个相同的结点，则找到了它们的公共结点。显然，该算法的时间复杂度为 O(len1xlen2)。

   ​	接下来我们试着去寻找一个线性时间复杂度的算法。先把问题简化:如何判断两个单向链表有没有公共结点?应注意到这样一个事实:若两个链表有一个公共结点，则该公共结点之后的所有结点都是重合的，即它们的最后一个结点必然是重合的。因此，我们判断两个链表是不是有重合的部分时，只需要分别遍历两个链表到最后一个结点。若两个尾结点是一样的，则说明它们有公共结点，否则两个链表没有公共结点。

   ​	然而，在上面的思路中，顺序遍历两个链表到尾结点时，并不能保证在两个链表上同时到达尾结点。这是因为两个链表长度不一定一样。但假设一个链表比另一个长k个结点，我们先在长的链表上遍历k个结点，之后再同步遍历，此时我们就能保证同时到达最后一个结点。由于两个链表从第一个公共结点开始到链表的尾结点，这一部分是重合的，因此它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。根据这一思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历长度之差个结点之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。此时，该方法的时间复杂度为 O(len1 +len2)。

   

6. 设C={a1,b1,a2,b2,.…,an,bn}为线性表，采用带头结点的单链表存放，设计一个就地算法，将其拆分为两个线性表，使得A={a1,a2,…,an},B={bn,…,b2, b1}。

   ```c
   void chaifen(Linklist &C,Linklist &A,LinkList &B){
       LNode *p=C->next,*q;
       LNode *rA=A,*hB=B;
       bool flag=true;		//flag为true表示是a的节点，为false表示是b的节点
       while(p!=NULL){
           if(flag){	//尾插法构建A
               rA->next=p;
               rA=p;
               p=p->next;
               rA->next=NULL; // 断开连接，防止链接到后面的节点
               flag=!flag;
           }else
           {			//头插法构建B
               q=p;
               p=p->next;
               q->next=hB->next;
               hB->next=q;
               flag=!flag;
           }
       }
   }
   ```

   

7. 在一个递增有序的单链表中，存在重复的元素。设计算法删除重复的元素，例如(7,10,10,21,30,42,42,42,51,70)将变为(7,10,21,30,42,51,70).

   ```c
   void DeleteSame(LinkList &L){
       LNode *p=L->next,*pre=L,*q;	//从第二个节点开始遍历查找
       while(p!=NULL){	//若L->next不存在，说明只有一个节点，无需删除
           if(p->data==pre->data){	//若当前节点的值与其前节点值相同，则需删除
           	q=p;
               p=p->next;
               pre->next=p;
               free(q);
           }
           else
           {
               pre=p;
               p=p->next;
           }
       }
   }
   ```

   

8. 设A和B是两个单链表(带头结点)，其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表 C，要求不破坏A、B 的结点。

   ```c
   void GetCommon(Linklist A,Linklist B,Linklist &C){
       LNode *pa=A->next,*pb=B->next,*r=C;
       while(pa!=NULL && pb!=NULL){
           if(pa->data<pb->data)
               pa=pa->next;
           else if(pb->data<pa->data)
               pb=pb->next;
           else{	//若相等，则使用尾插法插入到C中，确保仍为递增有序
               LNode *pc=(LNode *)malloc(sizeof(LNode));
               pc->data=pa->data;
               r->next=pc;
               pc->next=NULL;
               r=pc;
               pa=pa->next;
               pb=pb->next;
           }
       }
   }
   ```

   

9. 已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于 A链表中。

   ```c
   void GetCommon(LinkList &A,LinkList &B){
       LNode *pa=A,*pb=B,*h=A;
       while(pa!=NULL && pb!=NULL){
           if(pa->data<pb->data)
               pa=pa->next;
           else if(pb->data<pa->data)
               pb=pb->next;
           else{
               ElemType x=pa->data;
               pa=pa->next;
               pb=pb->next;
               h->data=x;
               h=h->next;
           }
       }
       h->next=NULL;
   }
   
   //王道答案
   LinkList Union(LinkList &la,LinkList &lb){
       LNode *pa=la->next,*pb=lb->next,*u,*pc=la;	//结果表中当前合并节点的前驱指针pc
       while(pa&&pb){
           if(pa->data==pb->data){
               pc->next=pa;	//A节点连接到结果表
               pc=pa;
               pa=pa->next;
               u=pb;	//释放u节点
               pb=pb->next;
               free(u);
           }
           else if(pa->data<pb->data){
               u=pa;
               pa=pa->next;
               free(u);
           }else{
               u=pb;
               pb=pb->next;
               free(u);
           }
       }
       while(pa){
           u=pa;
           pa=pa->next;
           free(u);
       }
       while(pb){
           u=pb;
       	pb=pb->next;
           free(u);
       }
       pc->next=NULL;
       free(lb);
       return la;
   }
   ```

   

10. 两个整数序列 A=a1,a2,a3,…,am和B=b1,b2,b3,…,bn已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列。

    ```c
    bool test(LinkList A, LinkList B) {		//假设有头节点
        if (!A || !B || !A->next || !B->next) {
            return false; // 空链表处理
        }
        LNode *pa = A->next;
        LNode *pb = B->next;
        LNode *start = pa;
        while (pa) {
            start = pa; // 记录A中可能的起始位置
            pb = B->next;	//从b1进行匹配
            while (pa && pb && pa->data == pb->data) {
                pa = pa->next;
                pb = pb->next;
            }
            if (!pb) { // B遍历完，说明是子序列
                return true;
            }
            if (!pa) { // A遍历完且pb未遍历完，不是子序列
                return false;
            }
            pa = start->next; // 回到起始位置的下一个节点继续查找
        }
        return false;
    }
    
    //王道答案
    bool Pattern(LinkList A,LinkList B){
        LNode *p=A;			//p为A链表的工作指针，假定A和B都无头节点
        LNode *pre=p;		//pre记录每趟比较中A链表开始节点
        LNode *q=B;			//q是B链表的工作指针
        while(p&&q)
            if(p->data==q->data){
                p=p->next;
                q=q->next;
            }else{
                pre=pre->next;
                p=pre;		//A链表新的开始比较节点
                q=B;		//q从B链表第一个节点开始
            }
        if(q==NULL)			//说明B比较结束
            return true;
        else
            return 0;
                
    }
    ```

    

11. 设计一个算法用于判断带头结点的循环双链表是否对称。

    ```c
    bool Symmetry(DLinkList L){
        DNode *p=L->next,*q=L->prior;
        while(p!=q && q->next!=p)	//**注意：此处第二个条件表示要让p和q交错中间位置，不可写成p->next!=q，否则会跳过检查偶数节点下中间位置两侧的节点值
            if(p->data==q->data){
                p=p->next;
                q=q->prior;
            }else
                return false;
        return true;
    }
    ```

    

12. 有两个循环单链表，链表头指针分别为 h1 和 h2，编写一个函数将链表 h2 链接到链表h1之后，要求链接后的链表仍保持循环链表形式。

    ```c
    void Union(LinkList &h1,LinkList &h2){
        LNode *r1=h1,*r2=h2;
        while(r1->next!=h1)		//遍历找到h1和h2的尾节点
            r1=r1->next;
        while(r2->next!=h2)
            r2=r2->next;
        r1->next=h2;
        r2->next=h1;
    }
    ```

    

13. 设有一个带头结点的非循环双链表L，其每个结点中除有 pre、data 和 next 域外,还有一个访问频度域 freq,其值均初始化为零。每当在链表中进行一次 Locate(L,x)运算时，令值为x的结点中 freq 域的值增1，并使此链表中的结点保持按访问频度递减的顺序排列，且最近访问的结点排在频度相同的结点之前，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的Locate(L,x)函数，返回找到结点的地址，类型为指针型。

    ```c
    DNode* Locate(DLinkList &L,ElemType x){
        DNode *p=L->next;
        while(p){
            if(p->data==x){
                p->freq+=1;
                if(p==L->next || p->freq<p->prior->freq)	//若p是第一个节点，或者增加后仍小于其前驱，直接返回
                    return p;
                DNode *q=p->prior;
                while(q->freq<=p->freq)
                    q=q->prior;		//向前遍历找出第一个freq大于p的节点
                p->prior->next=p->next;		//摘下p节点
                if(p->next!=NULL)p->next->prior=p->prior;	
                p->next=q->next;
                p->prior=q;
                q->next=p;
                p->next->prior=p;
                return p;
            }
            p=p->next;
        }
        return NULL;
    }
    ```

    

14. 设将n(n>1)个整数存放到不带头结点的单链表工中，设计算法将L中保存的序列循环右移k(0<k<n)个位置。例如，若k=1，则将链表(0,1,2,3}变为{3,0,1,2}。要求:

    1)给出算法的基本设计思想。

    2)根据设计思想，采用C或C++语言描述算法，关键之处给出注释

    3)说明你所设计算法的时间复杂度和空间复杂度。

    ```c
    //1)：遍历查找得到倒数第k+1个节点记为nh，这个节点在移动后就是新链表的尾节点，而他的next节点则是新链表的第一个节点，将链表先首位连接成环，将链表指针L指向nh->next，再在nh处断开环
    void Move(LinkList &L,int n,int k){
        if(k<=0||k>=n) return;
        LNode *p=L,*r,*nh;
        int i=0;
        while(p->next!=NULL){
            if(i==n-k-1)	//记录倒数第k+1个节点，该节点后面的倒数第k个节点就是移动后链表的第一个节点
                nh=p;
            i++;
            p=p->next;
        }
        r=p;
        r->next=L;		//临时链成环
        L=nh->next;		//更新第一个节点
        nh->next=NULL;	//断开尾节点处的环
        
    }
    //3)时间复杂度O(n)，空间复杂度O(1)
    
    //王道答案：先链成环在查找节点，最后断开
    LNode *Converse(LNode *L,int k){
        int n=1;	//保存链表长度
        LNode *p=L;
        while(p->next!=NULL){
            p=p->next;
            n++;
        }
        p->next=L;		//链成环
        for(int i=1;i<n;i++)	//寻找第n-k个节点
            p=p->next;
        L=p->next;
        p->next=NULL;
        return L;
    }
    ```

    

15. ##### ✨单链表有环，是指单链表的最后一个结点的指针指向了链表中的某个结点(通常单链表的最后一个结点的指针域是空的)。试编写算法判断单链表是否存在环。

    1)给出算法的基本设计思想。

    2)根据设计思想，采用C或C++语言描述算法，关键之处给出注释

    3)说明你所设计算法的时间复杂度和空间复杂度。

    ```c
    //1)设置快慢两个指针分别为fast和slow最初都指向链表头 head。slow 每次走一步，即slow=slow->next;fast每次走两步，即fast=fast->next->next。fast比slow走得快，若有环，则 fast一定先进入环，而slow后进入环。两个指针都进入环后，经过若干操作后两个指针定能在环上相遇。这样就可以判断一个链表是否有环。
    
    LNode* FindLoopStart(LinkList L){
        LNode *fast=L,*slow=L;
        while(fast!=NULL &&fast->next!=NULL){
            slow=slow->next;		//slow每次走一步，fast每次走两步
            fast=fast->next->next;
            if(slow==fast)
                break;
        }
        if(fast==NULL || fast->next==NULL)
            return NULL;
        LNode *p1=head,*p2=slow;		//分别指向头节点和相遇点
        while(p1!=p2){
            p1=p1->next;
            p2=p2->next;
        }
        return p1;						//p1与p2相遇处记为环入口
    }
        
    //3)O(n) O(1)
    ```

    

16. 设有一个长度n(n为偶数)的不带头结点的单链表，且结点值都大于0，设计算法求这个单链表的最大孪生和。孪生和定义为一个结点值与其孪生结点值之和，对于第i个结点(从0开始)，其孪生结点为第 n-i-1个结点。要求:

    1)给出算法的基本设计思想。

    2)根据设计思想，采用C或C++语言描述算法，关键之处给出注释。

    3)说明你的算法的时间复杂度和空间复杂度

    ```c
    //1)设置快、慢两个指针分别为 fast 和 s1ow，初始时 s1ow 指向L(第一个结点)，fast 指向L->next(第二个结点)，之后slow每次走一步，fast 每次走两步。当 fast 指向表尾(第n个结点)时，slow正好指向链表的中间点(第n/2个结点)，即slow正好指向链表前半部分的最后一个结点。将链表的后半部分逆置,然后设置两个指针分别指向链表前半部分和后半部分的首结点,在遍历过程中计算两个指针所指结点的元素之和，并维护最大值。
    
    int PairSum(LinkList L){
        LNode *fast=L->next,*slow=L;
        while(fast!=NULL && fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        LNode *newHead=NULL,*p=slow->next,*tmp;
        while(p!=NULL){		//将链表后一半元素反转，用头插法
            tmp=p->next;	//tmp暂存下一节点
            p->next=newHead;	//将p所指向节点插入新链表
            newHead=p;		//更新新链表头节点
            p=tmp;			//继续处理下一节点
        }
        p=L;
        LNode *q=newHead;
        int mx=p->data+q->data;
        while(p!=NULL){		//同时便利新旧两个节点记录最大值
            if((p->data+q->data)>mx)
                mx=p->data+q->data;
            p=p->next;
            q=q->next;
        }
        return mx;
    }
    
    //3) O(n),O(1)
    ```
    
    
    
17. 【2009】已知一个带有表头结点的单链表，结点结构为

    ```
    -------------------
    |  data  |  link  |
    -------------------
    ```

    假设该链表只给出了头指针 list。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结点的 data 域的值，并返回1;否则，只返回0。要求:
    1)描述算法的基本设计思想
    2)描述算法的详细实现步骤
    3)根据设计思想和实现步骤，采用程序设计语言描述算法(使用 C、C++或 Java 语言实现)，关键之处请给出简要注释。

18. ccc

19. 33333

### 栈和队列

#### 3.1 栈

3. 栈的初态和终态均为空，以I和O分别表示入栈和出栈，则出入栈的操作序列可表示为由I和O组成的序列，可以操作的序列称为合法序列，否则称为非法序列。写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回 false(假定被判定的操作序列已存入一维数组中)

   ```c
   bool Judge(char x[]){
       int i=0,o=0;
       while(x[k]!='\0'){
           if(x[k]=='I')
               i++;
       else
           if(x[k]=='O')
               o++;
       else
           return false;	//出现其他字符，报错
           if(o>i)			//当出栈次数>入栈次数，报错
               return false;
           k++;
       }
       if(i==o)
           return true;
       else				//栈中仍有剩余，报错
           return false;
   }
   ```

   

4. 设单链表的表头指针为L，结点结构由 data 和 next 两个域构成，其中 data 域为字符型。试设计算法判断该链表的全部n 个字符是否中心对称。例如 xyx、xyyx 都是中心对称。

   ```c
   bool Duichen(LinkList L){
       LNode *p=L;
       int n=0;
       char x;
       SqStack S;
       InitStack(S);
       while(p!=NULL){
           n++;
           push(S,p->data);
           p=p->next;
       }
       p=L;
       for(int i=0;i<n/2;i++){
           pop(S,x)
           if(p->data!=x)
               return false;
           p=p->next;
       }
       return true;
   }
   ```

   

5. 设有两个栈 S1、S2 都采用顺序栈方式，并共享一个存储区[0,…,maxsize-1]，为了尽量利用空间，减少溢出的可能，可采用栈顶相向、迎面增长的存储方式。试设计 S1、S2 有关入栈和出栈的操作算法。

   ```c
   int data[maxsize];
   int top1=-1,top2=maxsize;
   void S1Push(SqStack &S1,int x){
       if((top1+1)!=top2)
           data[++top1]=x;
       else
           return ;
   }
   
   void S1Pop(SqStack &S1,int x){
       if(top1!=-1)
           x=data[top1--];
       else
           return ;
   }
   
   void S2Push(SqStack &S2,int x){
       if((top2-1)!=top1)
           data[--top2]=x;
       else
           return ;
   }
   
   void S2Pop(SqStack &S2,int x){
       if(top2!=maxsize)
           x=data[top2++];
       else
           return ;
   }
   
   //王道答案
   #define maxsize 100
   #define elemtp int		//假设元素类型为整型
   typedef struct{
       elemtp stack[maxsize];
       int top[2];
   }stk;
   bool InitStack(stk &s){
       s.top[0]=-1;
       s.top[1]=maxsize;
       return true;
   }
   stk s;
   InitStack(s);
   //入栈
   void push(int i,elemtp x){
       if(i!=0&&i!=1)
           return ;
       if(s.top[0]+1==s.top[1])
           return ;
       switch(i){
           case 0:s.stack[++s.top[0]]=x;return ;
           case 1:s.stack[--s.top[1]]=x;return ;
       }
   }
   //出栈
   void pop(int i,elemtp &x){
       if(i!=0&&i!=1)
           return ;
       switch(i){
           case 0:
               if(s.top[0]==-1) 
                   return ;
               x=s.stack[s.top[0]--];
               return ;
           case 1:
               if(s.top[1]==maxsize)
                   return ;
               x=s.stack[s.top[1]++];
               return ;
       }
   }
   ```
   



#### 3.2 队列

1. 若希望循环队列中的元素都能得到利用，则需设置一个标志域 tag，并以 tag 的值为 0或1来区分队头指针 front 和队尾指针rear 相同时的队列状态是“空”还是“满”。试编写与此结构相应的入队和出队算法。

   ```c
   //假定tag=0表示空，tag=1表示满
   bool Enqueue(SqQueue &Q,ElemType x){
       if(Q.front==Q.rear && Q.tag==1)
           return false;
       else{
           Q.data[Q.rear]=x;
           Q.rear=(Q.rear+1)%maxsize;
           if(Q.front==Q.rear)
               Q.tag=1;
           return true;
       }
   }
   
   bool Dequeue(SqQueue &Q,ElemType &x){
       if(Q.front==Q.rear && Q.tag==0)
           return false;
       else{
           x=Q.data[Q.front];
           Q.front=(Q.front+1)%maxsize;
           if(Q.front==Q.rear)
               Q.tag=0;
           return true;
       }
   }
   ```

   

2. Q是一个队列，S是一个空栈，实现将队列中的元素逆置的算法。

   ```c
   void Reverse(SqQueue &Q,SqStack &S){
       ElemType x;
       while(!QueueEmpty(Q)){
           DeQueue(Q,x);
           Push(S,x);
       }
       while(!StackEmpty(S)){
           Pop(S,x);
           Enqueue(S,x);
       }
   }
   ```

   

3. 利用两个栈 S1和 S2 来模拟一个队列，已知栈的4个运算定义如下

   ```c
   Push(S,x);			//元素x入栈S
   Pop(S,x);			//s出栈并将出栈的值赋给x
   StackEmpty(S);		//判断栈是否为空
   StackOverflow(S);	//判断栈是否满
   ```

   如何利用栈的运算来实现该队列的3个运算(形参由读者根据要求自己设计)?

   ```c
   Enqueue;		//将元素x入队
   Dequeue;		//出队，并将出队元素存储在x中
   QueueEmpty;		//判断队列是否为空
   ```

   ```c
   //假定S1用于入队，S2用于出队，S2长度大于等于S1
   
   bool QueueEmpty(Stack S1,Stack S2){
       return StackEmpty(S1) && StackEmpty(S2);
   }
   
   bool Enqueue(Stack &S1,Stack &S2,ElemType x){
   	if(StackOverflow(S1)){		//若S1已满
           if(!StackEmpty(S2))		//S2中有数据，不能将S1中数据移动到S2
               return false;
           else{					//S2为空，可以将S1数据移动到S2
               while(!StackEmpty(S1)){
                   ElemType t;
                   Pop(S1,t);
                   Push(S2,t);
               }
           	Push(S1,x);
           	return true;         
           }
       }
       else{
           Push(S1,x);
           return true;
       }
   }
   
   bool Dequeue(Stack &S1,Stack &S2,ElemType &x){
       if(QueueEmpty(S1,S2))
           return false;
       else{
           if(StackEmpty(S2)){
               while(!StackEmpty(S1)){
                   ElemType t;
                   Pop(S1,t);
                   Push(S2,t);
               }//while
           }//if
           Pop(S2,x);
           return true;
       }
   }
   ```

   

4. 【2019 统考真题】请设计一个队列，要求满足:①初始时队列为空；②入队时，允许增加队列占用空间；③出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；④入队操作和出队操作的时间复杂度始终保持为O(1)。请回答:



#### 3.3 栈和队列的应用

1. 假设一个算术表达式中包含圆括号、方括号和花括号3种类型的括号，编写一个算法来判别表达式中的括号是否配对，以字符“\0”作为算术表达式的结束符。

   ```c
   bool Kuohao(char x[]){
       int i=0;
       char top='\0';
       SqStack S;
       InitStack(S);
       while(x[i]!='\0'){
           if(x[i]=='('||x[i]=='['||x[i]=='{')	//如果是左括号，入栈
               Push(S,x[i]);
           else
               {
               switch(x[i]){				//如果是右括号，则弹出栈顶元素，检查其是否为对应的左括号
                   case ')':
                       if (EmptyStack(S))  // 如果栈为空，意味着右括号没有匹配的左括号
                           return false;
                       Pop(S,top);
                       if(top!='(')
                           return false;
                       break;
                   case ']':
                       if (EmptyStack(S))  // 如果栈为空，意味着右括号没有匹配的左括号
                           return false;
                       Pop(S,top);
                       if(top!='[')
                           return false;
                       break;
                   case '}':
                       if (EmptyStack(S))  // 如果栈为空，意味着右括号没有匹配的左括号
                           return false;
                       Pop(S,top);
                       if(top!='{')
                           return false;
                       break;
               } //switch
           }//else
           i++;
       }
       if(EmptyStack(S))	//若遍历结束后栈为空，说明匹配成功
       	return true;
       else
           return false;
   }
   ```
   
   

### ✨树与二叉树

#### 5.2 二叉树的概念

5. 已知一棵二叉树按顺序存储结构进行存储，设计一个算法，求编号分别为i和j的两个结点的最近的公共祖先结点的值。

   ```c
   ElemType FindAncestor(SqTree T, int i, int j) {
       if(T[i].isEmpty || T[j].isEmpty)
           return 0;
       while (i != j) {  // 循环直到找到公共祖先
           if (i > j)
               i = i / 2;  // i节点向上走
           else
               j = j / 2;  // j节点向上走
       }
       return T[i];  // 返回公共祖先的值
   }
   
   ```

#### 5.3 二叉树的遍历和线索二叉树

1. 编写后序遍历二叉树的非递归算法。

   ```c
   void LRN(BiTree T)	//后序
   {
       Stack S;
       InitStack(S);
       BiTNode *p=T,*r=NULL;	//r作为辅助指针，指明上次访问的节点，从而判断是访问完哪棵子树后回到的根节点
       while(p || !S.isEmpty){
           if(p){
               Push(S,p);
               p=p->lchild;
           }else{
               GetTop(S,p);
               if(p->rchild && p->child!=r)	//若存在右子树，且还没访问右子树，就转向右
                   p=p->rchild;
               else{
                   Pop(S,p);
                   visit(p);
                   r=p;		//r记录访问的节点
                   p=NULL;
               }
           }
       }
   }
   ```

2. 试给出二叉树的自下而上、从右到左的层次遍历算法。

   ```c
   void InvertLevel(BiTree T){
       Stack S;
       Queue Q;
       BiTNode *p;
       if(T){
           InitStack(S);
           InitStack(Q);
           EnQueue(Q,T);
           while(!EmptyQueue(Q)){
               DeQueue(Q,p);
               if(p->lchild)
                  EnQueue(Q,p->lchild);
               if(p->rchild)
                  EnQueue(Q,p->rchild);
               Push(S,p);
           }	//while
           while(!EmptyStack(S)){
               Pop(S,p);
               visit(p);
           }	//while
       }	//if
   }
   ```

3. ##### ✨假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。

   ```c
   int Depth(BiTree T){	//采用层次遍历求解二叉树高度，此法可用于求解某层节点数、每层节点数、树的最大宽度等
       if(!T)	//空树高为0
           return 0;
       int last=0,level=0;		//last指向当前层的最右节点，初始设为根节点0，level的值比正在访问的层次少1
       int front=-1,rear=-1;
       BiTree Q[MaxSize];
       Q[++rear]=T;			//根节点入队
       BiTree p;
       while(front<rear){
           p=Q[++front];
           if(p->lchild)
           	Q[++rear]=p->lchild;
           if(p->rchild)
               Q[++rear]=p->rchild;
           if(front==last){	
               level++;
               last=rear;		//last指向下层最右侧节点
               //当遍历结束时，front与last最后一次相遇，层次加+1，使lever的值等于实际树高
           }
       }
       return level;
   }
   
   //补充：递归方式
   int Depth2(BiTree T){
       if(!T)
           return 0;
       ldep=Depth2(T->lchild);
       rdep=Depth2(T->rchild);
       if(ldep>rdef)		//树的高度为子树最大高度加根节点
           return ldep+1;
       else
           return rdep+1;
   }
   ```

   

4. 二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。

   ```c
   //通过层次遍历将每个节点的子节点全部入队（无论是否为NULL），如果是完全二叉树，那么当出现第一个空节点时，队列中剩下的节点应全为空，如果不是完全二叉树，那么队列中仍有不为空的节点。
   bool IsComplete(BiTree T){	
       Queue Q;
       InitQueue(Q);
       BiTNode *p;
       if(!T)	//空树为完全二叉树
           return true;
       EnQueue(Q,T);
       while(!EmptyQueue(Q)){
           DeQueue(Q,p);
           if(p){
               EnQueue(Q,p->lchild);
               EnQueue(Q,p->rchild);
           }//if
           else{	//若为空节点，检查队列中是否还有非空节点，无则是，有则非完全二叉树
               while(!EmptyQueue){
                   DeQueue(Q,p);
                   if(p)
                       return false;
               }//while
           }//else
       }//while
       return true;
   }
   ```

   

5. 假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。

   ```c
   //非递归实现：层次遍历检查每个节点的分支情况
   int DoubleSon(BiTree T){	
       if(!T)
           return 0;
       Queue Q;
       InitQueue(Q);
       BiTNode *p;
       EnQueue(Q,T);
       int sum=0;
       while(!EmptyQueue(Q)){
           DeQueue(Q,p);
           if(p->lchild && p->rchild)
               sum++;
           if(p->lchild) EnQueue(Q,p->lchild);
           if(p->rchild) EnQueue(Q,p->rchild);
       }
       return sum;
   }
   
   //王道答案：递归实现
   //f(b)=0	若b=NULL
   //f(b)=f(b->lchild)+f(b->rchild)+1	若*b为双分支节点
   //f(b)=f(b->lchild)+f(b->rchild)	其他情况（单分支或叶节点）
   int DsonNodes(BiTree b){
       if(b==NULL)
           return 0;
       else if(b->lchild && b->rchild)
           return DsonNodes(b->lchild)+DsonNodes(b->rchild)+1;
       else
           return DsonNodes(b->lchild)+DsonNodes(b->rchild);
   }
   ```

   

6. 设树B是一棵采用链式结构存储的二叉树，编写一个把树B中所有结点的左、右子树进行交换的函数。

   ```c
   void ExchangeSon(BiTree &T){	
       if(!T)
           return ;
       Queue Q;
       InitQueue(Q);
       BiTNode *p,*l,*r;
       EnQueue(Q,T);
       while(!EmptyQueue(Q)){
           DeQueue(Q, p);
           
           // 交换左右子树
           l = p->lchild;
           r = p->rchild;
           p->lchild = r;
           p->rchild = l;
   
           // 根据原左右子树入队
           if(l) EnQueue(Q, l);
           if(r) EnQueue(Q, r);
       }
   }
   
   //王道答案：递归实现
   void swap(BiTree b){
       if(b){
           swap(b->lchild);	//递归交换其左子树的左右子树
           swap(b->rchild);	//递归交换其右子树的左右子树
           
           BiTNode *temp=b->lchild;	//交换其左右子树
           b->lchild=b->rchild;
           b->rchild=temp;
       }
   }
   ```

   

7. 假设二叉树采用二叉链存储结构存储，设计一个算法，求先序遍历序列中第 k(1≤k<二叉树中结点个数)个结点的值。

   ```c
   //非递归实现
   ElemType Findk(BiTree T,int k){
       if(!T || k<1)
           return NULL;
       if(k==1)
           return T->data;
       Stack S;
       InitStack(S);
       BiTNode *p=T;
       int i=1;
       while(p || !EmptyStack(S)){
           if(p){
               if(i==k)
                   return p->data;
               else{
                   Push(S,p);
                   p=p->lchild;
                   i++;
               }//else
           }//if(p)
           else{
               Pop(S,p);
               p=p->rchild;
           }//else
       }//while
       return NULL;
   }
   
   //递归实现：
   int i=1;
   ElemType FindK2(BiTree b,int k){
       if(!b)
           return '#';
       if(i==k)
           return b->data;
       i++;
       ElemType ch;
       ch=Findk2(b->lchild,k);
       if(ch!='#')
           return ch;
       ch=Findk2(b->rchild,k);
       return ch;
   }
   ```

   

8. ##### ✨已知二叉树以二叉链表存储，编写算法完成：对于树中每个元素值为x的结点，删除以它为根的子树，并释放相应的空间。

   ```c
   void DeleteXTree(BiTNode *bt){
       if(bt){
           DeleteXTree(bt->lchild);
           DeleteXTree(bt->rchild);
           free(bt);
       }
   }
   void DelX(BiTree &T,ElemType x){
       if(!T)
           return ;
       if(T->data==x){	
           DeleteXTree(T);
           return ;
       }
       Queue Q;
       InitQueue(Q);
       EnQueue(Q,T);
       while(!EmptyQueue(Q)){
           DeQueue(Q,p);		//从根节点开始，第一个节点的值肯定不是x，所有检查他的左右子树
           if(p->lchild){		
               if(p->lchild->data==x){		//若左子树值为x，删除其左子树
                   DeleteXTree(p->lchild);
               	p->lchild=NULL;
               }
           }else
               EnQueue(Q,p->lchild);		//否则左子树进入队列继续遍历
           if(p->rchild){					//若右子树值为x，删除其右子树
               if(p->rchild->data==x){
                   DeleteXTree(p->rchild);
               	p->rchild=NULL;
               }
           }else
               EnQueue(Q,p->rchild);		//否则右子树进入队列继续遍历
       }
   }
   ```

   

9. ##### ✨在二叉树中查找值为x的结点，试编写算法(用C语言)打印值为x的结点的所有祖先,假设值为x的结点不多于一个。

   ```c
   //采用非递归后序遍历，最后访问根节点，访问值为x的节点时，栈中所有节点均为该节点的祖先
   typedef struct{
       BiTNode *t;
       int tag;
   }stack;		//tag=0表示左子女被访问，tag=1表示右子女被访问
   void FindAncestor(BiTree T,ElemType x){
       if(!T)
           return ;
       stack s[MaxSize];
       top=0;
       BiTNode *p=T;
       while(p || top>0){
           while(p && p->data!=x){		//节点入栈
               s[++top].t=p;
               S[top]=0;
               p=p->lchild;			//沿左分支向下
           }
           if(p && p->data==x){		//找到x
               for(int i=1;i<=top;i++)
                   printf("%d\n",s[i].t->data);
               return ;
           }
           while(top!=0 && s[top].tag==1)	//退栈直到分支点
               top--;
           if(top!=0){					//沿右分支向下遍历
               s[top].tag=1;			
               p=s[top].t->rchild;
           }
       }
   }
   ```

   

10. 设一棵二叉树的结点结构为(LLINK,INFO,RLINK)，ROOT 为指向该二叉树根结点的指针，p 和 q分别为指向该二叉树中任意两个结点的指针，试编写算法 ANCESTOR(ROOT,p,q,r)，找到p和q的最近公共祖先结点r。

    ```c
    //寻找p和q的公共祖先结点r，不失一般性，设p在q的左边。算法思想:采用后序非递归算法，栈中存放二叉树结点的指针，当访问到某结点时，栈中所有元素均为该结点的祖先。后序遍历必然先遍历到结点P，栈中元素均为p的祖先。先将栈复制到另一辅助栈中。继续遍历到结点q时，将栈中元素从栈顶开始逐个到辅助栈中去匹配，第一个匹配(即相等)的元素就是结点p和q的最近公共祖先。
    typedef struct{
        BiTNode *t;
        int tag;		//tag=0表示左子女被访问，tag=1表示右子女被访问
    }stack;
    
    void ANCESTOR(BiTree ROOT,BiTNode *p,BiTNode *q,BiTNode *r){
        if(!ROOT)
            return ;
        stack s[MaxSize];
        stack S1[MaxSize];
        int top=0,top1=0;
        BiTNode *bt=ROOT;
        while(bt &&top>0){
            while(bt){		//沿左下遍历
                s[++top].t=bt;
                s[top].tag=0;
                bt=bt->lchild;
            }
            while(top!=0 && s[top].tag==1)		//栈不为空且栈顶指针已访问右节点，则检查栈顶指针的值，出栈
            {
                if(s[top].t==p){		//假定p在q的左侧，遇到p时，栈中元素均为p的祖先
                    for(int i=1;i<=top;i++)
                        s1[i]=s[i];		//保存p的祖先到s1
                    top1=top;
                }
                if(s[top].t==q)
                    for(int i=top;i>0;i--)
                        for(int j=top1;j>0;j--)		//逐一匹配s1与s的节点，寻找相同祖先
                            if(s1[j].t==s[i].t)
                                r=s[i].t;
                top--;		//退栈
            }
            if(top!=0){		//栈不为空且栈顶指针还未访问右节点，沿右下遍历
                s[top].tag=1;
                bt=s[top].t->rchild;
            }
        }//while
        return ;
    }
    ```

    

11. ##### 假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树b的宽度(即具有结点数最多的那一层的结点个数)。

    ```c
    int Width(BiTree b) {
        if (!b)
            return 0;
    
        int front = 0, rear = 0, width = 0;  // 初始化队列指针和宽度
        BiTree Q[MaxSize];  // 定义一个队列
        Q[rear] = b;  // 根节点入队
    
        while (front <= rear) {  // 队列不为空
            int levelSize = rear - front + 1;  // 当前层的节点个数
    
            // 更新最大宽度
            if (levelSize > width) 
                width = levelSize;
    
            // 遍历当前层的所有节点，并将下一层节点入队
            for (int i = 0; i < levelSize; i++) {
                BiTree p = Q[front++];  // 当前节点出队
    
                if (p->lchild)
                    Q[++rear] = p->lchild;  // 左孩子入队
                if (p->rchild)
                    Q[++rear] = p->rchild;  // 右孩子入队
            }
        }
        
        return width;
    }
    ```

    

12. 设有一棵满二叉树(所有结点值均不同)，已知其先序序列为pre，设计一个算法求其后序序列 post。

    ```c
    void PreToPost(ElemType pre[],int l1,int h1,ElemType post [],int l2,int h2){
        int half;
        if(h1>=l1){
            post[h2]=pre[l1];		//每次递归讲子树pre中的第一个节点(根节点)放到post的最后位置
            half=(h1-l1)/2;
            PreToPost(pre,l1+1,l1+half,post,l2,l2+half-1);		//调整左子树
            PreToPost(pre,l1+half+1,h1,post,l2+half,h2-1);		//调整右子树
        }
    }
    
    void int main(){
        ElemType *pre="ABCDEFG";
        ElemType post[MaxSize];
        PreToPost(pre,0,6,post,0,6);
        for(int i=0;i<=6;i++)
            printf("%c",post[i]);
    }
    ```

    

13. 设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为 head。二叉树按二叉链表方式存储，链接时用叶结点的右指针域来存放单链表指针。

    ```c
    //先序遍历中先遇到的叶节点保存起来，在遇到叶节点时进行连接
    void LinkLeaf(BiTree T,BiTNode *head){
        if(!T)
            return ;
        BiTNode *p=T,*preleaf=NULL;	//p用于先序遍历，preleaf用于保存前一个叶节点
        Stack S;	//S栈用于保存先序遍历的节点
        InitStack(S);
        while(p || !EmptyStack(S)){
            if(p){
                if(!p->lchild && !p->rchild ){
                    if(!preleaf)	//若preleaf为空，说明是第一个叶节点
                    {
                        head=p;
                        preleaf=p;
                    }
                    else{	//否则进行链接，并更新preleaf
                        preleaf->rchild=p;
                        preleaf=p;
                    }
                }//if
                Push(S,p);
                p=p->lchild;
            }else{
                Pop(S,p);
                p=p->rchild;
            }
        }//while
    }
    
    //王道答案：递归中序遍历
    LinkedList head,pre=NULL;
    LinkedList InOrder(BiTree bt){
        if(bt){
            InOrder(bt->lrchild);	//中序遍历左子树
            if(!bt->lchild &&!bt->rchild){
                if(pre==NULL)
                {	
                    head=bt;
                	pre=bt;
                }else{
                    pre->rchild=bt;
                    pre=bt;
                }
            }//if(!bt->lchild &&!bt->child)
            InOrder(bt->rchild);	//中序遍历右子树
        }
        return head;
    }
    ```

    

14. 试设计判断两棵二叉树是否相似的算法。所谓二叉树T1和T2相似，指的是T1和T2都是空的二叉树或都只有一个根结点；或者T1的左子树和T2的左子树是相似的，且T1的右子树和T2的右子树是相似的。

    ```c
    bool Similar(BiTree T1, BiTree T2) {
        // 如果两棵树都为空，则它们是相似的
        if (T1 == nullptr && T2 == nullptr) 
            return true;
    
        // 如果只有一棵树为空，则它们不相似
        if (T1 == nullptr || T2 == nullptr) 
            return false;
    
        // 递归判断左子树和右子树是否相似
        bool L = Similar(T1->lchild, T2->lchild);
        bool R = Similar(T1->rchild, T2->rchild);
    
        // 左右子树都要相似，才返回 true
        return L && R;
    }
    ```

    

15. 【2014 统考真题】二叉树的带权路径长度(WPL)是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树T，采用二叉链表存储，结点结构为

#### 5.4 树、森林

1. 编程求以孩子兄弟表示法存储的森林的叶结点数。

   ```c
   typedef struct FNode{
       ElemType data;
       struct FNode *fristchild,*nextsibling;
   }FNode,*FTree;
   
   //遍历查找左子树为空的节点数，这里使用先序遍历
   int Leaf(FTree T){
       if(!T)
           return 0;
       int n=0;
       Stack S;
       InitStack(S);
       FNode *p=T;
       while(p || !EmptyStack(S)){
           if(p){
               if(!p->firstchild)
                   n++;
               Push(S,p);
               p=p->firstchild;
           }else{
               Pop(S,p);
               p=p->nextsibling;
           }
       }//while
       return n;
   }
   
   //王道递归实现
   int Leaves(FTree T){
       if(!T)
           return 0;
       if(!T->firstchild)
           return 1+Leaves(T->nextsibling);
       else
           return Leaves(T->firstchild)+Leaves(T->nextsibling);
   }
   ```

2. 以孩子兄弟链表为存储结构，请设计递归算法求树的深度。

   ```c
   int Height(FTree T) {
       if (!T) 
           return 0;
       
       // 递归求当前节点子树的深度和兄弟节点的深度
       int childDepth = Height(T->firstchild);    // 子树的深度
       int siblingDepth = Height(T->nextsibling); // 兄弟树的深度
   
       // 当前节点的深度 = 1 + 子树深度
       return max(1 + childDepth, siblingDepth);
   }
   
   ```

   

### 图

#### 6.2 图的存储及基本操作

5. 写出从图的邻接表表示转换成邻接矩阵表示的算法。

   ```c
   #define MaxVertexNum 100
   typedef char VertexType;		//顶点对应的数据类型
   typedef int EdgeType;			//边对应的数据类型
   
   //邻接表
   typedef struct ArcNode{			//边表节点
       int adjvex;					//该弧所指向的顶点的位置
       struct ArcNode *nextarc;	//指向下一条弧的指针
       EdgeType info;				//边权值
   }ArcNode;
   typedef struct VNode{			//顶点表节点
       VertexType data;			//顶点信息
       ArcNode *firstarc;			//指向第一条依附该顶点的弧的指针
   }VNode,AdjList[MaxVertexNum];
   typedef struct{
       AdjList vertices;			//邻接表
       int vexnum,arcnum;			//图的顶点数和弧数
   }ALGraph;
   
   //邻接矩阵
   typedef struct{
       VextexType vex[MaxVertexNum];
       EdgeType edge[MaxVertexNum][MaxVertexNum];
   }MGraph;
   
   //假设A与M均已完成初始化等操作
   void ALToM(ALGraph A, MGraph &M) {
       // 初始化邻接矩阵
       for (int i = 0; i < A.vexnum; i++) {
           for (int j = 0; j < A.vexnum; j++) {
               M.edge[i][j] = 0;  // 初始化为0，表示无边的情况
           }
       }
   
       // 复制顶点信息
       for (int i = 0; i < A.vexnum; i++) {
           M.vex[i] = A.vertices[i].data;
       }
       
       // 填充邻接矩阵
       for (int i = 0; i < A.vexnum; i++) {
           ArcNode *p = A.vertices[i].firstarc;  // 遍历顶点i的边表
           while (p) {
               M.edge[i][p->adjvex] = p->info;  // 将边权值写入邻接矩阵
               p = p->nextarc;  // 移动到下一条弧
           }
       }
   
   }
   
   ```

6. 【2021】已知无向连通图G由顶点集 V和边集E组成，|E|>0，当G中度为奇数的顶点个数为不大于2的偶数时，G存在包含所有边且长度为|E|的路径(称为 EL路径)。设图G采用邻接矩阵存储，类型定义如下：

7. 【】

#### 6.3 图的遍历

2. 给定一个连通无向图，采用邻接表存储，将图的所有顶点分别染成红色或蓝色，若存在一种染色方法使图中每条边的两个顶点的颜色都不相同，则称这个图能被二分。

   ![image-20240912212954200](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20240912212954200.png)

   1)判断上面两个无向图是否能被二分，若能被二分，则请标出每个顶点的颜色

   2)请设计一种算法用来判断图是否能被二分，仅用语言描述算法的思想即可。

   3)给出你设计的算法的时间复杂度和空间复杂度。

   ```c
   /*
   1)左边的可以，右边的不行
   2)从任意一个结点开始，将其染成红色，并从该结点开始对整个图进行遍历，在遍历过程中，若当前遍历的结点a有一条边指向b，则可能出现三种情况:
   ①b未被染色，将它染成与结点a不同的颜色，并且继续遍历与b相连的结点;
   ②a与b的颜色相同，说明该图不能被二分，直接返回;
   ③a与b的颜色不同，跳过b点。
   3)上述遍历无论是使用深度优先还是使用广度优先，时间复杂度都为(n+m)，其中的和 m分别是顶点数和边数。需要一个数组来存储各结点的颜色及是否已访问，空间复杂度为 O(n)。
   */
   ```

   

3. 试设计一个算法，判断一个无向图 G是否为一棵树。若是一棵树，则算法返回 true,否则返回 false。

   ```c
   //无向图为树的条件是：无环连通图或者边数为n-1的连通图
   bool IsTree(Graph G){
       bool visited[G.vexnum];
       for(int i=0;i<G.vexnum;i++)
           visited[i]=false;
       int Vnum=0,Enum=0;			//记录DFS遍历过的顶点数和边数
       DFS(G,1,Vnum,Enum,visited);
       if(Vnum==G.vexnum && Enum==2*(G.vexnum-1))
           return true;			//一次DFS就遍历了所有点，边数为n-1，说明G是有n-1条边的连通图
       else
           return false;
   }
   void DFS(Graph G,int v,int &Vnum,int Enum,bool visited[]){	//深度优先遍历G，统计访问过的顶点数和边数，通过Vnum和Enum返回
       visited[v]=true;
       Vnum++;
       int w=FirstNeighbor(G,v);		//取v的第一个邻接顶点
       while(w!=-1){
           Enum++;						//顶点存在时，边存在，计数
           if(!visited[w])				//若当前顶点未访问，则访问该顶点
               DFS(G,w,Vnum,Enum,visited);
           w=NextNeighbor(G,v,w);
       }
   }
   ```

   

4. 分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表方式存储的有向图中是否存在由顶点Vi到顶点Vj的路径(i≠j)。注意，算法中涉及的图的基本操作必须在此存储结构上实现。

   ```c
   //从vi出发，依次遍历各个顶点，遇到vj则说明存在路径
   bool visited[MaxSize]={false};
   void DFS(ALGraph G,int i,int j,bool %can_reach){
       if(i==j)
       {
           can_reach=true;
       	return ;
       }
       visited[i]=true;
       for(int p=FirstNeighbor(G,i);p>=0;p=NextNeighbor(G,i,p))
           if(!visited[p]&&!can_reach)		//递归遍历检测邻接点
               DFS(G,p,j,can_reach);
   }
   
   bool BFS(ALGraph G,int i,int j){
       Queue(Q);
       InitQueue(Q);
       EnQueue(Q,i);			//顶点i入队
       while(!isEmpty(Q)){		//非空循环
           DeQueue(Q,i);
           visited[i]=true;
           if(i==j)
               return true;
           for(int p=FirstNeighbor(G,i);p>=0;p=NextNeighbor(G,i,p)){	//检查i的所有邻接点
               if(p==j)
                   return true;
               if(!visited[p]){		//继续遍历
                   EnQueue(Q,p);
                   visited[p]=true;
               }
           }
       }
   }
   ```

   

5. 假设图用邻接表表示，设计一个算法，输出从顶点Vi到顶点Vj的**所有**简单路径。

   ```c
   void FindPath(ALGraph G,int u,int v,bool v,int path[],int d){
       int w;
       ArcNode *p;
       d++;				//路径长度增1
       path[d]=u;			//将当前顶点添加到路径中
       visited[u]=true;	//置已访问标记
       if(u==v)			//找到一条路径则输出
           print(path[]);	//输出路径上的点
       p=G->adjlist[u].firstarc;	//p指向u的第一个相邻点
       while(p!=NULL){
           w=p->adjvex;	//若w未访问，递归访问它
           if(!visited[w])
               FindPath(G,w,v,path,d);		//p指向u的下一个相邻点
           p=p->nextarc;
       }
       visited[u]=0;		//恢复环境，使该顶点可重复使用
   }
   ```
   
   

#### 6.4 图的应用

7. 试编写利用 DFS 实现有向无环图拓扑排序的算法。

   ```c
   bool TopologicalSort(Graph G){
       InitStack(S);		//初始化栈，存储入度为0的顶点
       int i;
       for(i=0;i<G.vexnum;i++){
           if(indegree[i]==0)
               Push(S,i);		//将所有入读为0的顶点入栈
       }		
       int count=0;			//计数，记录当前已经输出的顶点数
       while(!EmptyStack(S)){	//栈不为空，则存在入度为0的顶点
           Pop(S,i);			//栈顶元素出栈
           print[count++]=i;	//输出顶点i
           for(p=G.vertices[i].firstarc;p;p=p->nextarc){	//将所有i指向的顶点入度减1，并且将入度减为0的顶点压入栈S
               v=p->adjvex;
               if(!(--indegree[v]))
                   Push(S,v);
           }
       }//while
       if(count<G.vexnum)
           return false;		//排序失败，有向图中有回路
       else
           return true;
   }
   ```

   

### 查找

#### 7.2 顺序查找和折半查找

4. 写出折半查找的递归算法。初始调用时，low为1，high为ST.length。

5. 线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱结点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。

6. 已知一个n阶矩阵A和一个目标值k。该矩阵无重复元素，每行从左到右升序排列，每列从上到下升序排列。请设计一个在时间上尽可能高效的算法，判断矩阵中是否存在目标值k。例如，矩阵为，目标值为 8，判断存在。要求:

   1)给出算法的基本设计思想。

   2)根据设计思想，采用C或 C++语言描述算法，关键之处给出注释

   3)说明你的算法的时间复杂度和空间复杂度。

## 算法真题

#### 2010

设将n(n>1)个整数存放到一维数组R中。设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0<p<n)个位置，即将R中的数据由(X0,X1,…,Xn-1)变换为(Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1)。要求:

   1)给出算法的基本设计思想。

   2)根据设计思想，采用C或 C++或 Java 语言描述算法，关键之处给出注释

   3)说明你所设计算法的时间复杂度和空间复杂度。

```c
//优解：先将n各数据原地逆置，再分别将前n-p和后p各元素分别原地逆置。时间复杂度O(n)，空间复杂度O(1)
void reverse(int R[],int low,int high){
    int temp;
    while(low<high){
        temp=R[low];
        R[low]=R[high];
        R[high]=temp;
        high--;
        low++;
    }
}
void Move(int R[],int n,int p){
    if(p<=0||p>=n)
        return;
    reverse(R,0,n-1);
    reverse(R,0,n-p-1);
    reverse(R,n-p,n-1);
}
//暴力解：使用辅助数组暂存左移出的前p各元素，左移结束后再存回R。时间复杂度O(n)，空间复杂度O(p)
void MoveP(int R[],int n,int p){
    if(p<=0||p>=n)
        return;
    int *temp=(int *)malloc(sizeof(int)*p);
    int i=0;
    for(;i<p;i++)
        temp[i]=R[i];
    for(;i<n;i++)
        R[i-p]=R[i];
    for(i=n-p;i<n;i++)
        R[i]=temp[i-n+p];
    free(temp);		//凡是申请辅助空间，勿忘最后释放
}
```



#### 2011

42.(15 分)一个长度为L(L≥1)的升序序列 S，处在第⌈L/2⌉(向上取整)位置的数称为S的中位数。例如，若序列 S1=(11,13,15,17,19)，则 S1 的中位数是 15。两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 S2=(2,4,6,8,10)，则 S1 和 S2 的中位数是11。现在有两个等长升序序列A 和 B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：
(1)给出算法的基本设计思想。

(2)根据设计思想，采用 C、C++或 Java 语言描述算法，关键之处给出注释

(3)说明你所设计算法的时间复杂度和空间复杂度。

```c
//(1)先检查两个序列的第一位和最后一位，若存在一个序列的最后一位小于等于另一个序列的第一位，则另一个序列的第一位即为中位数。再同时遍历两个序列，每次将当前值较小的序列向后一位，当遍历到两个序列的第L+1位时，即为所求的中位数

int FindMiddle(int* A, int* B, int L) {
    if (A[L - 1] <= B[0])	return B[0];
    else if (A[0] >= B[L - 1])	return A[0];
    else {
        int i = 0, j = 0, k = 0, middle = A[0];
        for(i=0;i<L;i++) {
            if (A[j] < B[k]) 
                middle = A[j++];		//注意：先保留遍历到的第[i]个值在增加索引
            else 
                middle = B[k++];		//注意：先保留遍历到的第[i]个值在增加索引
        }
        return middle;
    }
}

//(3)时间复杂度为O(L)，空间复杂度为O(1)
```



参考答案：

1）求两个序列 A和 B的中位数最简单的办法就是将两个升序序列进行归并排序，然后求其中位数。这种解法虽可求解，但在时间和空间两方面都不大符合高效的要求，但也能获得部分分值。

根据题目分析，分别求两个升序序列 A和 B的中位数，设为a和b。

① 若a=b，则a或b即为所求的中位数。

原因:容易验证，如果将两个序列归并排序，则最终序列中，排在子序列ab 前边的元素为先前两个序列中排在a和b前边的元素;排在子序列 ab 后边的元素为先前两个序列中排在a和b后边的元素。所以子序列 ab 一定位于最终序列的中间，又因为a=b，显然a就是中位数。

② 否则(假设 a<b)，中位数只能出现(a, b)范围内。

原因:同样可以用归并排序后的序列来验证，归并排序后必然有形如…a…b…的序列出现，中位数必出现在(a,b)之间。因此可以做如下处理:舍弃a所在序列 A的较小一半，同时舍弃b所在序列 B的较大一半。在保留两个升序序列中求出新的中位数a和b，重复上述过程，直到两个序列中只含一个元素时为止，则较小者即为所求的中位数。每次总的元素个数变为原来的一半。

算法的基本设计思想如下：

分别求出序列 A 和 B 的中位数，设为a和b，求序列A和B的中位数过程如下:

① 若a=b，则a或b即为所求中位数，算法结束。

② 若 a<b，则舍弃序列 A 中较小的一半，同时舍弃序列 B 中较大的一半，要求舍弃的长度相等。

③ 若 a>b，则舍弃序列 A 中较大的一半，同时舍弃序列 B 中较小的一半，要求舍弃的长度相等。

在保留的两个升序序列中，重复过程①、②、③，直到两个序列中只含一个元素时为止，较小者即为所求的中位数。

```c
int M_Search(int A[],int B[],int n){
    int s1=0,d1=n-1,m1,s2=1,d2=n-1,m2;	//分别表示序列A和序列B的首位数、末位数和中位数
    while(s1!=d1 || s2!=d2){
        m1=(s1+d1)/2;
        m2=(s2+d2)/2;
        if(A[m1]==B[m2])		//满足条件1）
            return A[m1];		
        if(A[m1]<B[m2]){		//满足条件2）
            if((s1+d1)%2==0)	//若元素个数为奇数
            {	
                s1=m1;			//舍弃A中间点以前的部分，保留中间点
                d2=m2;			//舍弃B中间点以后的部分，保留中间点
            }
            else{				
                s1=m1+1;		//舍弃A中间点以前的部分，保留中间点
                d2=m2;			//舍弃B中间点以后的部分，保留中间点
            }
        }
        else{					//满足条件3）
            if((s1+d1)%2==0)	//若元素个数为奇数
            {
                d1=m1;			//舍弃A中间点以前的部分，保留中间点
                s2=m2;			//舍弃B中间点以后的部分，保留中间点
            }
            else{				//元素个数为偶数
                d1=m1+1;		//舍弃A中间点以前的部分，保留中间点
                s2=m2;			//舍弃B中间点以后的部分，保留中间点
            }
        }
    }
    return A[s1]<B[s2]? A[s1]:B[s2];
}
```

3）时间复杂度为O(logn)，空间复杂度为O(1)

#### 2012

42 假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，则可共享相同的后缀存储空间，例如，“loading”和“being”的存储映像如下图所示,

![image-20240929132927046](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20240929132927046.png)

设st1和,str2分别指向两个单词所在单链表的头结点，链表结点结构为

```c
-------------
| data |next|
-------------
```

请设计一个时间上尽可能高效的算法,找出由 str1 和 str2所指向两个链表共同后缀的起始位置(如图中字符i所在结点的位置p)。要求:

1)给出算法的基本设计思想。

2)根据设计思想，采用C或C++或 Java语言描述算法，关键之处给出注释。

3)说明你所设计算法的时间复杂度。

```c
LinkNode *Find(LinkList str1,LinkList str2){
    LinkNode *S1[MaxSize],*S2[MaxSize];		//使用S1和S2模拟栈，保存遍历过程中两个链表的节点
    LinkNode *p1=str1,*p2=str2;
    int top1=0,top2=0;
    while(p1)		//遍历两个链表
    {
        S1[top1++]=p1;
        p1=p1->next;
    }
    while(p2){
        S2[top2++]=p2;
        p2=p2->next;
    }
    while(top1!=-1 && top2!=-1){		//两个栈均不为空时逐一出栈对比栈顶元素，直到出现第一个不相同的位置
        if(S1[--top1].data!=S2[--top2].data)
            return S1[top1+1];
    }
    return NULL;
}
```



参考答案：

顺序遍历两个链表到尾结点时，并不能保证两个链表同时到达尾结点。这是因为两个链表的长度不同。假设一个链表比另一个链表长k个结点，我们先在长链表上遍历k个结点，之后同步遍历两个链表，这样就能够保证它们同时到达最后一个结点。由于两个链表从第一个公共结点到链表的尾结点都是重合的，所以它们肯定同时到达第一个公共结点。

![image-20240929134445897](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20240929134445897.png)

算法的基本设计思想:

①分别求出 strl和 str2 所指的两个链表的长度 m 和 n。

② 将两个链表以表尾对齐:令指针p、q分别指向 str1和str2的头结点，若 m≥n，则使p指向链表中的第m-n+1个结点;若m<n，则使q指向链表中的第n-m+1个结点，即使指针p和q所指的结点到表尾的长度相等。

③ 反复将指针p和q同步向后移动，并判断它们是否指向同一结点。若p和q指向同一结点，则该点即为所求的共同后缀的起始位置。

2014

```c
typedef struct TNode{
    int weight;
    struct TNode *left,*right;
}TNode;
int sum=0,high=0;
void LRN(TNode T){
    if(T->left){
        LRN(T->left);
        high++;
    }
    if(T->right){
        LRN(T->right);
        high++;
    }
    if(!T->left && !T->right){
        sum=sum+high*T->weight;
        high--;
    }
}
```

#### 2013

![image-20241118162757003](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20241118162757003.png)

```c
//1)先对A进行快排，如果存在主元素，则必为n/2除的元素，因此从n/2处分别向两边遍历统计出现次数，若出现次数大于n/2，则存在主元素，否则不存在

int huafen(int A[], int low, int high) {
    int mid = A[low];
    while (low < high) {
        while (low < high && A[high] >= mid)
            high--;
        A[low] = A[high];
        while (low < high && A[low] <= mid)
            low++;
        A[high] = A[low];
    }
    A[low] = mid;
    return low;
}

void QuickSort(int A[], int low, int high) {
    if (low >= high)
        return;
    int mid = huafen(A, low, high);
    QuickSort(A, low, mid - 1);
    QuickSort(A, mid + 1, high);
}

void func(int A[], int n) {
    QuickSort(A, 0, n - 1);
    int x = A[n / 2];
    int count = 1;
    for (int i = n / 2-1; i >= 0 && A[i] == x; i--)
        count++;
    for (int i = n / 2+1; i < n && A[i] == x; i++)
        count++;
    if (count > n / 2)
        printf("%d\n", x);
    else
        printf("%d\n", -1);
}

//3)时间复杂度O(nlogn)，空间复杂度O(logn)
```



#### 2017

![image-20241124164012912](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20241124164012912.png)

二叉树结点定义如下：

```c
typedef struct node{
    char data[10];
    struct node *left,*right;
}BTree;
```

要求:
(1)给出算法的基本设计思想
(2)根据设计思想，采用C或 C++语言描述算法，关键之处给出注释

```c
/*
表达式树的中序序列加上必要的括号即为等价的中缀表达式。可以基于二叉树的中序遍历策略得到所需的表达式。(3 分)
表达式树中分支结点所对应的子表达式的计算次序，由该分支结点所处的位置决定。为得到正确的中缀表达式，需要在生成遍历序列的同时，在适当位置增加必要的括号。显然，表达式的最外层(对应根结点)及操作数(对应叶结点)不需要添加括号。(2分)
*/

void LNR(BTree *p){
    if(p==NULL)
        return ;
    if(p->left==NULL && p->right==NULL){
        printf("%s",p->data);
    }else{
        printf("(");
        LNR(p->left);
        printf("%s",p->data);
        LNR(p->right);
        printf(")");
    }
}
void func(BTree *T){
    LNR(T->left);
    printf("%s",T->data);
    LNR(T->right);
}

```



#### 2018

41.(13 分)给定一个含 n(n≥1)个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组{-5,3,2,3}中未出现的最小正整数是1;数组{1,2,3}中未出现的最小正整数是 4。要求:

(1)给出算法的基本设计思想。

(2)根据设计思想，采用C或 C++语言描述算法，关键之处给出注释。

(3)说明你所设计算法的时间复杂度和空间复杂度。

```c
#include <stdio.h>
#include <stdlib.h>

int FindMin(int A[], int n) {
    int* F = (int*)malloc(sizeof(int)*(n+1));
    int i, min;
    for (i = 0; i < n + 1; i++)
		F[i] = 0;
    for (i = 0; i < n; i++)
    {
        if (A[i] > 0 && A[i] < n + 1)
        {
            F[A[i]]++;
        }
    }
    for (i = 1; i < n + 1; i++)
        if (F[i] == 0)
        {
            free(F);
            return i;
        }
    free(F);
    return n + 1;
}

int main() {
	int A[] = { -5,3,2,3 };
	int n = sizeof(A) / sizeof(A[0]);
	printf("%d", FindMin(A, n));
	return 0;
}
```

#### 2019

设线性表L=(a1,a2,a3,...,an-2,an-1,an)采用带头结点的单链表保存，链表中的结点定义如下

```c
typedef struct node{
    int data;
    struct node *next;
}NODE;
```

请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L 中的各结点，得到
线性表L=(a1,an,a2,an-1,a3,an-2,...)要求：

（1）给出算法的基本设计思想。

（2）根据设计思想，采用C 或C++语言描述算法，关键之处给出注释。

（3）说明你所设计的算法的时间复杂度。

```c
/*一、快慢指针确定中间节点
二、原地逆置后半链表
三、将逆置后的后半链表间隔插入前半链表之中*/

void func(NODE *L){
    NODE *p=L,*q=L,*r,*s;
    while(q!=NULL&&q->next!=NULL)
    {
        q=q->next->next;
        p=p->next;
    }//结束时p节点到达链表中间位置
    q=p->next;
    p->next=NULL;
    while(q!=NULL){		//头插法逆置后边链表
        r=q->next;
        q->next=p->next;
        p->next=q;
        q=r;
    }
    s=L->next;
    q=p->next;
    p=->next=NULL;
    while(q!=NULL)	//合并前后链表
    {
        r=q->next;
        q->next=s->next;
        s->next=q;
        s=q->next;
        q=r;
    }
}
```

#### 2020 三元组表的最短距离

![image-20241128163847345](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20241128163847345.png)

![image-20241128164011862](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20241128164011862.png)

```c
int abs(int x) {
	if (x < 0) {
		return -x;
	}
	else {
		return x;
	}
}

int MinD(int A[], int n1, int B[], int n2, int C[], int n3) {
	int i = 0, j = 0, k = 0;
	int min = abs(A[0] - B[0]) + abs(B[0] - C[0]) + abs(C[0] - A[0]);
	while (i < n1 && j < n2 && k < n3) {
		int temp = abs(A[i] - B[j]) + abs(B[j] - C[k]) + abs(C[k] - A[i]);
		if (temp < min) {
			min = temp;
		}
		if ( A[i] < B[j] && A[i] < C[k]) {
			i++;
		}
		else if (B[j] < A[i] && B[j] < C[k]) {
			j++;
		}
		else k++;
	}
	return min;
}
```

#### 2024 唯一拓扑排序

![image-20241203144843144](C:\Users\11548\AppData\Roaming\Typora\typora-user-images\image-20241203144843144.png)

```c
typedef struct	//图的类型定义
{
    int numVertices, numEdges;		//图的顶点数和有向边数
    char VerticesList[MAXV];		//顶点表，MAXV为已定义常量
    int Edge[MAXV][MAXV];			//邻接矩阵
}MGraph;

/*
1)记图的顶点数为n，遍历n次图的邻接矩阵，每次遍历时检查有无入度为0的顶点
若有一个入度为0的顶点，将其记为nowVisit，将其连接的边删除(即将Edge的第nowVisit行全部置0)，然后继续遍历，直到结束；
若入度为0的顶点数量为0或2个及以上，则说明不存在唯一拓扑排序，结束遍历。
为防止已访问过的点在后序遍历中误判为入度为0的点，还需要使用一个visited数组记录顶点访问情况，当发现入度为0的顶点同时检查visited，若visited==1，说明该点已访问，跳过。
*/

// 计算每个顶点的入度，存储在 inDegree 数组中
void calculateInDegree(MGraph G, int inDegree[]) {
    memset(inDegree, 0, sizeof(int) * G.numVertices); // 初始化入度数组为 0
    for (int i = 0; i < G.numVertices; i++) {
        for (int j = 0; j < G.numVertices; j++) {
            inDegree[j]+=G.Edge[i][j];		//统计各点的入度
            }
        }
    }
}

// 判定是否存在唯一的拓扑序列
int uniquely(MGraph G) {
    int *inDegree=(int *)malloc(sizeof(int)*G.numVertices);    // 记录每个顶点的入度
    int *visited(int *)malloc(sizeof(int)*G.numVertices);     // 记录顶点访问情况
    int visitedCount = 0;  // 已访问的顶点数量

    memset(visited, 0, sizeof(int) * G.numVertices); // 初始化 visited 数组
    calculateInDegree(G, inDegree); // 计算初始入度

    for (int k = 0; k < G.numVertices; k++) { // 遍历 n 次
        int count = 0;      // 入度为 0 的顶点数量
        int nowVisit = -1;  // 当前入度为 0 且未访问的顶点序号

        // 查找入度为 0 且未访问的顶点
        for (int i = 0; i < G.numVertices; i++) {
            if (inDegree[i] == 0 && visited[i] == 0) { // 入度为 0 且未访问
                count++;
                nowVisit = i;
            }
        }

        if (count == 1) { // 唯一的入度为 0 的顶点
            visited[nowVisit] = 1; // 标记该顶点已访问
            visitedCount++;        // 访问的顶点数加 1
            // 删除该顶点的出边，并更新入度数组
            for (int j = 0; j < G.numVertices; j++) {
                if (G.Edge[nowVisit][j] != 0) {
                    inDegree[j]--; // 出边指向的顶点入度减 1
                }
            }
        } else { // 若入度为 0 的顶点数不为 1
            return 0; // 拓扑排序不唯一
        }
        
    }

    // 若所有顶点均已访问，返回 1（存在唯一拓扑排序）
    return (visitedCount == G.numVertices) ? 1 : 0;
}

```

